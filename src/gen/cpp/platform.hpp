// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from platform.djinni

#pragma once

#include "duration.hpp"
#include <memory>
#include <optional>
#include <vector>

namespace interaxon { namespace example {

class Action;
class BluetoothConnectionCallback;
class BluetoothConnectionHandle;
class BluetoothDevice;
class BluetoothDeviceCallback;
class DeviceCallbackHandle;
class Errorable;
class IntervalHandle;

class Platform {
public:
    virtual ~Platform() {}

    /**
     * Act at some later time in the caller's thread. If until is 0, act will be
     * run as soon as possible but not until after the caller has returned (i.e.
     * defer_action will not block if act blocks.)
     */
    virtual void defer_action(const std::shared_ptr<Action> & act, const Duration & until) = 0;

    /**
     * Runs act immediately in a new thread. Calls error() if something went
     * wrong setting up the thread.
     */
    virtual void thread_action(const std::shared_ptr<Errorable> & act) = 0;

    /**
     * Run r at the specified interval. Runs as frequently at possible if the
     * interval is 0 (or is less than the time r takes to complete). Never runs
     * multiple times concurrently. Interval must be non-negative. If r cancels
     * the handle in do, r will not be called again.
     */
    virtual std::shared_ptr<IntervalHandle> repeat_action(const std::shared_ptr<Action> & act, const Duration & at_interval) = 0;

    /**
     * List of Bluetooth devices accessible to the API right now.
     * On Android, this is all paired devices. On iOS, this is all connected
     * devices.
     */
    virtual std::vector<std::shared_ptr<BluetoothDevice>> all_devices() = 0;

    /**
     * Return a Bluetooth device if one is available at any time before timeout.
     * Returns a null reference if the timeout expired.
     */
    virtual std::shared_ptr<BluetoothDevice> wait_for_device_until(const std::optional<Duration> & timeout) = 0;

    /**
     * Register a callback to be called any time a Bluetooth device becomes
     * available.
     */
    virtual std::shared_ptr<DeviceCallbackHandle> add_device_callback(const std::shared_ptr<BluetoothDeviceCallback> & callback) = 0;

    /** Initiate a non-blocking connection to the specified Bluetooth device. */
    virtual std::shared_ptr<BluetoothConnectionHandle> connect_to_device(const std::shared_ptr<BluetoothDevice> & device, const std::shared_ptr<BluetoothConnectionCallback> & callback) = 0;
};

} }  // namespace interaxon::example
