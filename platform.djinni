# General-purpose callable.
#
# This would be called 'Runnable' if we didn't mind the name conflict with
# java.lang.Runnable.
action = interface +c {
    do();
}

error_code = enum {
    # We have no idea what happened.
    unknown;
    # The other side refused our attempt.
    refused;
    # Our timeout expired.
    timeout;
    # The other side hung up.
    hangup;
    # We received corrupt or inconsistent data.
    corrupt;
    # We canceled the call.
    canceled;
    # The callee or remote end is overloaded.
    overloaded;
}

error = record {
    code: error_code;
    desc: optional<string>;
}

# Like action, but exposes a separate method to signal errors, e.g. in
# connection establishment or starting a thread.
errorable = interface +c {
    # Run on success.
    ok();

    # Run on failure. Returns true iff caller should retry the action.
    error(the_error: error): bool;
}

# Time representation.
#
# Really only serves to prevent the antipattern of postfixing all time-related
# integral parameters with '_microseconds'.
duration = record {
    # Must not be negative.
    microseconds: i64;
} deriving (eq, ord)

action_runner = interface +j +o {
    # Act at some later time in the caller's thread. If until is 0, act will be
    # run as soon as possible but not until after the caller has returned (i.e.
    # defer_action will not block if act blocks.)
    defer_action(act: action, until: duration);

    # Runs act immediately in a new thread.
    #
    # Calls error() if something went wrong setting up the thread. Only calls
    # ok() on a thread different from the one on which it was called. May call
    # error() from any thread.
    thread_action(act: errorable);

    # Run r at the specified interval. Runs as frequently at possible if the
    # interval is 0 (or is less than the time r takes to complete). Never runs
    # multiple times concurrently. Interval must be non-negative. If r cancels
    # the handle in do, r will not be called again.
    repeat_action(act: action, at_interval: duration): interval_handle;
}

# Handle used to cancel repeated actions.
interval_handle = interface +j +o {
    cancel();
}

# Provides various different mechanisms for getting a device corresponding to a
# Muse.
muse_device_manager = interface +j +o {
    # Returns all Muses we know about at this moment.
    all_muses(): list<bluetooth_device>;

    # Synchronously waits for a Muse until the timeout expires.
    #
    # If timeout is none, blocks indefinitely. If timeout is 0, returns
    # immediately. Return is null if no Muse appeared in time.
    wait_for_muse_until(timeout: optional<duration>): bluetooth_device;

    # Adds a callback to be called any time a Muse becomes available.
    add_device_callback(callback: bluetooth_device_callback):
        device_callback_handle;
}

bluetooth_device_callback = interface +c {
    got_device(device: bluetooth_device);
}

device_callback_handle = interface +j +o {
    cancel();
}

# Bluetooth device representation.
#
# May hold some platform-specific state, e.g. a Bluetooth socket on Android or
# an EAAccessory on iOS. It is therefore an interface and not a record.
bluetooth_device = interface +j +o {
    name(): string;
    address(): string;
    connect(callback: bluetooth_connection_callback):
        bluetooth_connection_handle;
}

# Owned by the native code. Used to signal that we want to write or end the
# connection.
bluetooth_connection_handle = interface +j +o {
    # Write zero or more bytes, returning the number of bytes written. Return
    # is always non-negative. If this returns 0, wait for can_write() to be
    # called on the callback.
    write(bytes: binary): i64;

    # Close the connection. on_close() receives an error_code of canceled.
    close();
}

# Owned by the platform code. Provides callbacks on various connection events.
bluetooth_connection_callback = interface +c {
    # Called once when the connection has opened successfully.
    on_open();

    # Called once when the connection ends for any reason. Returns true iff
    # caller should retry the connection.
    on_close(error: error): bool;

    # Called every time data is read from the connection. Callee must consume
    # (or buffer) all bytes.
    on_read(bytes: binary);

    # Called every time data can be written to the handle. Will be called
    # repeatedly as long as write is called on the handle and space is
    # available.
    can_write();
}
